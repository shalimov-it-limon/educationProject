# Запакованные переменные, или что такое *args и **kwargs
# Позиционные (positional) и именованные (keyword) аргументы.
# Из названий можно предположить, что одни аргументы зависят от позиции, а вторые — от имени.

# def func(a, b, c):
#     print('a =', a)
#     print('b =', b)
#     print('c =', c)
#
#
# func(4, 5, 6)
# # a = 1
# # b = 2
# # c = 3
#
#
# func(3, 2, 1)
# # a = 3
# # b = 2
# # c = 1
#
#
# def func(b, a, c):
#     print('a =', a)
#     print('b =', b)
#     print('c =', c)
#
#
# func(4, 5, 6)
# func(3, 2, 1)
# суть позиционных аргументов - куда поставил, так и отразилось.

#
# def func(a, b, c):
#     print('a =', a)
#     print('b =', b)
#     print('c =', c)
#
#
# func(a=1, b=2, c=3)
# # a = 1
# # b = 2
# # c = 3
#
# func(c=3, a=1, b=2)    # Место значения не имеет
# # a = 1
# # b = 2
# # c = 3


def func(c, b, a):    # Место значения не имеет, все строго по порядку.
    print('b =', b)   # Здесь устанавливается порядок вывода.
    print('a =', a)   # Здесь устанавливается порядок вывода.
    print('c =', c)   # Здесь устанавливается порядок вывода.


func(a=1, b=2, c=3)    # Место значения не имеет, все строго по порядку.
func(a=1, b=12, c=5)    # Место значения не имеет, все строго по порядку.

# суть именованных аргументов - в каком порядке в теле прописал, так и выведется.
# Важная особенность: все именованные аргументы должны идти строго после позиционных,
# как при объявлении функций, так и при их вызове.

# # Правильно
# func(a, b, c=3)
#
# # Неправильно
# func(a=1, b, c)

# переменное количество позиционных аргументов - оператор "*"
# позволяет «распаковывать» (получить все значения из какой-либо последовательности,
# а не саму последовательность) объекты (например, списки или кортежи), внутри которых хранятся некие элементы.
a = [1, 2, 3]
b = [a, 4, 5, 6]  # Список а вложили в список b.
print(b)
# [[1, 2, 3], 4, 5, 6]

a = [1, 2, 3]
b = [*a, 4, 5, 6]   # Через оператор "*" вытащили значения списка а в список b.
print(b)
# [1, 2, 3, 4, 5, 6]
print(a) # [1, 2, 3]
print(*a)  # 1 2 3

# Чтобы функция могла принимать неограниченное количество позиционных аргументов,
# есть специальная конструкция *args ("arguments" ), а для именованных аргументов — **kwargs
# (сокращение от "keyword arguments" (именованные аргументы)).
# Важно, что они должны начинаться с одной и двух звездочек соответственно.
# Каждая из этих конструкций используется для распаковки аргументов соответствующего типа,
# позволяя вызывать функции со списком аргументов переменной длины, как в случае функции print.
# args — это кортеж, а kwargs  — это словарь.


def my_func(*args, **kwargs):
   print(type(args))
   print(type(kwargs))

my_func()
# <class 'tuple'>
# <class 'dict'>

# функция сумматор, которая будет складывать любое количество переданных ей аргументов.


def adder(*nums):    # сумматор
    sum_ = 0
    for n in nums:
        sum_ += n

    return sum_


print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3, 1 + 2
print(adder(1, 2, 3))  # 6, 1 + 2 + 3

# функция, которая будет перемножать любое количество переданных ей аргументов.
print('My BAD Var')


def many_n(*nums):    #  * - args все "нумсы"
    pr = 0  # Умножь на 0 и получишь 0!
    for n in nums:
        pr *= n
    return pr


print(many_n(1))
print(many_n(2))

print('My GOOD Var')


def many_n(*nums):    #  * - все "нумсы"
    pr = 2
    for n in nums:
        pr *= n
    return pr


print(many_n(1, 5, 6))
print(many_n(2, 4))
print(many_n(5, 5, 10, 25))


def many_n(*nums):    #  * - все "нумсы"
    pr = 1
    for n in nums:
        pr *= n
    return pr


print(many_n(1, 5, 6))
print(many_n(2, 4))
print(many_n(5, 5, 10, 25))
print('Skill Var')


def mul(*nums):
    p = 1
    for n in nums:
        p *= n

    return p

# Изменяемые типы данных как аргументы по умолчанию.
# функция должна вести себя одинаково на одних и тех же входных данных и выдавать результат, который соответствует этим входным данным. Это одна из основных идей функционального программирования,
# то есть такого стиля написания кода, где всё опирается на функции.

def incorrect_func(name_arg=[]):
   # name_arg является локальной переменной
   print("Аргумент до изменения", name_arg)
   name_arg.append(1)   # Тут он добавил все поочередно и выковырял переменную b из задания про "*" ВЫШЕ!
   name_arg.append("b")
   name_arg.append(b)
   print("Аргумент после изменения", name_arg)

# вызовем несколько раз одну и ту же функцию.
# Видим увеличение, так как при передаче словаря передаются не все его значения, а указатель на первый его элемент.
incorrect_func()
print('-----')
incorrect_func()
print('-' * 50)
incorrect_func()
print('-----')
incorrect_func()

# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [1]
# Аргумент после изменения [1, 1]

# Если вдруг внутри функции нужно использовать списки, то этот момент можно обойти следующим образом:

# установим аргумент name_arg пустым а внутри функции будем проверять его


def correct_func(name_arg=None):   # Было name_arg=[]
    if name_arg is None:   # Если аргумент пустой, то
        name_arg = []      # сделаем из name_arg СПИСОК.
    print("Аргумент до изменения", name_arg)
    name_arg.append(1)   # А теперь к списку будем аппендить что-нибудь.
    print("Аргумент после изменения", name_arg)

# вызовем два раза одну и ту же функцию


correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])

# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]