# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
# squares = [i**2 for i in range(1,11)]
T = [[i*j for j in range(1,11)] for i in range(1,11)]
print(T)

# input(). На каждой итерации цикла консоль будет запрашивать
# данные для ввода и сохранять их в качестве элемента списка.

L = [input() for i in range(5)]
print(L)

# пример пять раз запросит у пользователя данные для входа и запишет их в список.
# Здесь же можно использовать сразу преобразование в необходимый тип, если он заранее известен.
# L = [int(input()) for i in range(5)]

# в список сохранялось True, если элемент четный, и False, если элемент нечетный.

L = [int(input()) % 2 == 0 for i in range(5)]
print(L)

# записать логическое выражение, используя all([ ]) и any([ ]) над списком четности,
# если его результат будет истинным тогда и только тогда, когда в списке
# есть хотя бы один четный и хотя бы один нечетный элемент.

any(L) and not all(L)
# есть два списка одинакового размера:

L = [i for i in range(10)]
# 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10,0,-1)]
# 10 9 8 7 6 5 4 3 2 1
# необходимо создать новый список, который будет состоять из произведений соответствующих элементов друг на друга.
# он должен выглядеть так
# 0 9 16 21 24 25 24 21 16 9
# Мы знаем, что элементов в списке десять, поэтому можем пробежаться в цикле по индексам от 0 до 10:
N = [ ]
for i in range(10):
    N.append(L[i] * M[i])
# функция zip(), которая позволяет объединить два списка в новый список кортежей, каждый из которых будет содержать по одному элементу из каждого списка.

for a in zip(L,M):
    print(a)
#(0, 10)
#(1, 9)
#(2, 8)
#(3, 7)
#(4, 6)
#(5, 5)
#(6, 4)
#(7, 3)
#(8, 2)
#(9, 1)

# Код можно сделать еще более приятным:

for a, b in zip(L,M):
    print('a =', a, 'b =', b)
#a = 0 b = 10
#a = 1 b = 9
#a = 2 b = 8
#a = 3 b = 7
#a = 4 b = 6
#a = 5 b = 5
#a = 6 b = 4
#a = 7 b = 3
#a = 8 b = 2
#a = 9 b = 1

# Сначала мы склеили два списка поэлементно, а потом на каждой итерации делали развертку кортежей на две переменные — a и b, которые использовали в теле самого цикла.
# Аналогично можно использовать функцию zip() и внутри генераторов списков.

# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.

N = [a*b for a, b in zip(L, M)]





